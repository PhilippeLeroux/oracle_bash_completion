# bash completion support for srvctl 12cR1
# vim: ts=4:sw=4:filetype=sh:cc=81

# Copyright (C) 2016,2017 Philippe Leroux <philippe.lrx@gmail.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

#	============================================================================
#	Pour mÃ©mo :
#		COMP_WORDS	is an array of words in the current command line.
#		COMP_CWORD	is the index of the current word in the command line.
#		COMPREPLY	is a list of replies.
#	============================================================================

#	============================================================================
#	Functions for debug

#	Work only with : export SRVCTL_LOG=yes
function _log
{
	if [ "$SRVCTL_LOG" == yes ]
	then # One log per user.
		if [ "$1" == "-n" ]
		then
			typeset -r first_arg="-n"
			shift
		else
			typeset -r first_arg
		fi
		echo $first_arg "$@" >> /tmp/srvctl_completion_${USER}.log
	fi
}

#	============================================================================
#	Tools functions

#	return 0 if $1 is a function, else return 1
function _function_exists
{
	[ "$(type -t "$1")" == "function" ] && return 0 || return 1
}

#	print the number of nodes to stdout
function _count_nodes
{
	wc -l<<<"$(olsnodes)"
}

#	return 0 if cluster, 1 if standalone server
function _is_cluster
{
	test $(_count_nodes) -gt 1
}

#	print to stdout dbname or empty string if not found.
function _get_dbname
{
	for i in $( seq $ifirstoption ${#COMP_WORDS[@]} )
	do
		case "${COMP_WORDS[i]}" in
			-db|-database)
				if [ x"${COMP_WORDS[i+1]}" == x ]
				then # no name after -db|-database
					echo ""
				else
					echo "${COMP_WORDS[i+1]}"
				fi
				return
				;;
		esac
	done

	# -db|-database not found.
	echo ""
}

#	return 0 if $1 is used in COMP_WORDS, else return 1
function _option_is_used
{
	typeset	-r opt="$1"

	typeset i
	for i in $( seq $ifirstoption ${#COMP_WORDS[@]} )
	do
		[ "$opt" == "${COMP_WORDS[i]}" ] && return 0 || true
	done

	return 1 # not found
}

#	============================================================================
#	build the reply : COMPREPLY is set.
function _reply
{
	COMPREPLY=( $( compgen -W "$@" -- ${COMP_WORDS[COMP_CWORD]} ) )
}

#	============================================================================
#	Functions to build objects for a command

# Generated by script : all_objects_for_cmd.sh
# Built object_list for current command
# srvctl version: 12.1.0.2.0
function _build_object_list_cluster
{
	case "$command" in
		relocate)
			typeset -g object_list="database service server vip scan scan_listener oc4j rhpserver rhpclient gns cvu mgmtdb filesystem asm havip"
			;;
		downgrade)
			typeset -g object_list="database"
			;;
		export)
			typeset -g object_list="gns"
			;;
		stop)
			typeset -g object_list="database instance service nodeapps vip asm listener scan scan_listener oc4j rhpserver rhpclient havip exportfs home filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		import)
			typeset -g object_list="gns"
			;;
		add)
			typeset -g object_list="database instance service service nodeapps vip network asm listener scan scan_listener srvpool oc4j rhpserver rhpclient havip exportfs filesystem gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		start)
			typeset -g object_list="database instance service nodeapps vip asm listener scan scan_listener oc4j rhpserver rhpclient havip exportfs home filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		status)
			typeset -g object_list="database instance service nodeapps vip listener asm scan scan_listener srvpool server oc4j rhpserver rhpclient home filesystem volume diskgroup cvu gns mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		remove)
			typeset -g object_list="database instance service nodeapps vip network asm listener scan scan_listener srvpool oc4j rhpserver rhpclient havip exportfs filesystem diskgroup gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		config)
			typeset -g object_list="database service nodeapps vip network asm listener scan scan_listener srvpool oc4j rhpserver rhpclient filesystem volume gns cvu exportfs mgmtdb mgmtlsnr mountfs"
			;;
		predict)
			typeset -g object_list="database service asm diskgroup filesystem vip network listener scan scan_listener oc4j"
			;;
		unsetenv)
			typeset -g object_list="database nodeapps vip listener asm mgmtdb mgmtlsnr"
			;;
		upgrade)
			typeset -g object_list="database"
			;;
		setenv)
			typeset -g object_list="database nodeapps vip listener asm mgmtdb mgmtlsnr"
			;;
		enable)
			typeset -g object_list="database instance service asm listener nodeapps vip scan scan_listener oc4j rhpserver rhpclient filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		disable)
			typeset -g object_list="database instance service asm listener nodeapps vip scan scan_listener oc4j rhpserver rhpclient filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		convert)
			typeset -g object_list="database database"
			;;
		getenv)
			typeset -g object_list="database nodeapps vip listener asm mgmtdb mgmtlsnr"
			;;
		modify)
			typeset -g object_list="database instance service service service service asm nodeapps listener network scan scan_listener srvpool oc4j rhpserver rhpclient filesystem gns cvu mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		update)
			typeset -g object_list="listener scan_listener database mgmtdb instance gns"
			;;
		*)
			_log "$command not supported."
			typeset -g object_list=""
	esac
}

# Generated by script : all_objects_for_cmd.sh
# Built object_list for current command
# srvctl version: 12.1.0.2.0
function _build_object_list_standalone
{
	case "$command" in
		downgrade)
			typeset -g object_list="database"
			;;
		stop)
			typeset -g object_list="database service asm listener diskgroup ons home"
			;;
		add)
			typeset -g object_list="database service asm listener ons"
			;;
		start)
			typeset -g object_list="database service asm listener diskgroup ons home"
			;;
		status)
			typeset -g object_list="database service asm listener diskgroup ons home"
			;;
		remove)
			typeset -g object_list="database service asm listener diskgroup ons"
			;;
		config)
			typeset -g object_list="database service asm listener ons"
			;;
		unsetenv)
			typeset -g object_list="database asm listener"
			;;
		upgrade)
			typeset -g object_list="database"
			;;
		setenv)
			typeset -g object_list="database asm listener"
			;;
		enable)
			typeset -g object_list="database service asm listener diskgroup ons"
			;;
		disable)
			typeset -g object_list="database service asm listener diskgroup ons"
			;;
		getenv)
			typeset -g object_list="database asm listener"
			;;
		modify)
			typeset -g object_list="database service asm listener ons"
			;;
		update)
			typeset -g object_list="database"
			;;
		*)
			_log "$command not supported."
			typeset -g object_list=""
	esac
}

#	init global variable object_list with all objects for the current command.
#	reply with object_list
function _reply_with_object_list
{
	if _is_cluster
	then
		_build_object_list_cluster
	else
		_build_object_list_standalone
	fi

	_reply "$object_list"
}

#	============================================================================
#	Function to do a reply with a set of options.

#	$@	option_list
#	print to stdout option_list with used options removed.
function _remove_used_options
{
	typeset	option_list="$@"

	for i in $( seq $ifirstoption ${#COMP_WORDS[@]} )
	do
		if [[ x"${COMP_WORDS[i]}" != x && $i -ne $COMP_CWORD
				&& "$option_list" == *"${COMP_WORDS[i]}"* ]]
		then
			option_list=${option_list/${COMP_WORDS[i]}/}
		fi
	done

	echo $option_list
}

#	Ex : srvctl stop service -db db_name [-node | -instance]
#	You can use -node or -instance, together it's an error.
#
#	$1 list options
#	print new list options to stdout.
function _remove_exclusive_options
{
	typeset	option_list="$@"

	typeset -A	exclusive_options
	exclusive_options+=( [list_1]="-db -serverpool -thisversion -thishome" )
	exclusive_options+=( [list_2]="-instance -node" )
	exclusive_options+=( [list_3]="-all -netnum -scannumber" )
	exclusive_options+=( [list_4]="-service -startoption" )
	exclusive_options+=( [list_5]="-listener -asmlistener -leaflistener" )
	exclusive_options+=( [list_6]="-env -envs" ) # order is important.

	typeset	-r	cur_word="${COMP_WORDS[COMP_CWORD]}"

	for id in ${!exclusive_options[@]}
	do
		typeset exlu_opts=${exclusive_options[$id]}
		typeset option
		for option in $exlu_opts
		do
			if [ "$option" != "$cur_word" ] && _option_is_used "$option"
			then
				typeset o2r	# option to removed.
				for o2r in ${exlu_opts/$option/}
				do	# cannot use option $o2r with $option, remove it.
					option_list=${option_list/$o2r/}
				done
				break
			fi
		done
	done

	echo "$option_list"
}

#	$1 option_list
#	before to reply :
#		- remove options already in use.
#		- remove incompatible options.
#
#	Callback functions on command should use this function, not _reply. Else
#	completion never stop.
function _reply_with_options
{
	typeset	option_list="$@"

	if [ $COMP_CWORD -ne $ifirstoption ]
	then
		# Call order is important !
		option_list="$(_remove_exclusive_options $option_list)"
		option_list="$(_remove_used_options $option_list)"
	fi

	_reply "$option_list"
}

#	============================================================================
#	Callback functions : _reply_with_[option]_list (option without dash)
#	Return values for an option or nothing if user must provide a value.
#	All this functions are called by _reply_for_option.

function _reply_with_database_list
{
	_reply "$(crsctl stat res							|\
					grep "\.db$"						|\
					sed "s/NAME=ora\.\(.*\).db/\1/g"	|\
					xargs)"
}

function _reply_with_diskgroup_list
{
	_reply	"$(crsctl stat res						|\
					grep -E "ora.*.dg$"				|\
					sed "s/NAME=ora.\(.*\).dg/\1/g"	|\
					xargs)"
}

function _reply_with_listener_list
{
	#	For RAC database we must exclude listener for scan vips.
	_reply	"$(crsctl stat res							|\
					grep -E "NAME=ora.*.lsnr$"			|\
					grep -v "SCAN"						|\
					sed "s/NAME=ora.\(.*\).lsnr/\1/g"	|\
					xargs)"
}

function _reply_with_oraclehome_list
{
	_reply	"$(cat /etc/oratab						|\
					grep -E "^(\+|[A-Z])"			|\
					sed "s/.*:\(.*\):[Y|N].*/\1/g"	|\
					xargs)"
}

function _reply_with_vip_list
{
	_reply	"$(crsctl stat res							|\
					grep -E "NAME=ora.*.vip$"			|\
					grep -v "scan"						|\
					sed "s/NAME=ora.\(.*\).vip/\1/g"	|\
					xargs)"
}

function _reply_with_netnum_list
{
	_reply "{1..$(crsctl stat res|grep -E "\.network$"|wc -l)}"
}

function _reply_with_scannumber_list
{
	_reply "1 2 3"
}

function _reply_all_node_numbers
{
	_reply "{1..$(_count_nodes)}"
}

alias _reply_with_startconcurrency_list=_reply_all_node_numbers
alias _reply_with_stopconcurrency_list=_reply_all_node_numbers

function _reply_with_node_list
{
	_reply "$(olsnodes | xargs)"
}

alias _reply_with_preferred_list=_reply_with_node_list
alias _reply_with_available_list=_reply_with_node_list
alias _reply_with_servers_list=_reply_with_node_list
alias _reply_with_server_list=_reply_with_node_list

function _reply_with_service_list
{
	typeset	dbname=$(_get_dbname)
	if [ x"$dbname" == x ]
	then # return all services
		_reply "$(crsctl stat res								|\
						grep -E "ora.*.svc$"					|\
						sed "s/NAME=ora\..*\.\(.*\)\.svc/\1/g"	|\
						xargs)"
	else # return services for specified database.
		typeset -r dbname=$(tr [:upper:] [:lower:]<<<"$dbname")
		_reply "$(crsctl stat res										|\
						grep -E "ora.$dbname.*.svc$"					|\
						sed "s/NAME=ora\.${dbname}\.\(.*\)\.svc/\1/g"	|\
						xargs)"
	fi
}

function _reply_with_instance_list
{
	typeset	-r dbname=$(_get_dbname)
	if [ x"$dbname" == x ]
	then
		COMPREPLY=()
		return 0
	fi

	if [ -v instance_list_cache ]
	then
		if [ $(( SECONDS - tt_instance_list_cache )) -lt $(( 60 * 10 )) ]
		then
			_reply "$instance_list_cache"
			return 0
		fi
		# cache to old.
	fi

	typeset	cmd="srvctl status database -db $dbname"
	cmd="$cmd | sed 's/Instance \(.*\) is.*/\1/g' | xargs"
	_log "cmd='$cmd'"

	typeset -g	instance_list_cache="$(eval $cmd)"
	typeset	-gi	tt_instance_list_cache=$SECONDS

	_reply "$instance_list_cache"
}

function _reply_with_startoption_list
{
	_reply "open mount read"
}

function _reply_with_stopoption_list
{
	_reply "normal transactional immediate abort"
}

function _reply_empty
{
	COMPREPLY=()
}

#	For this options user must provide a value.
alias _reply_with_statefile_list=_reply_empty
alias _reply_with_volume_list=_reply_empty
alias _reply_with_device_list=_reply_empty
alias _reply_with_name_list=_reply_empty
alias _reply_with_id_list=_reply_empty
alias _reply_with_envs_list=_reply_empty
alias _reply_with_env_list=_reply_empty
alias _reply_with_failoverdelay_list=_reply_empty
alias _reply_with_failoverretry_list=_reply_empty
alias _reply_with_edition_list=_reply_empty
alias _reply_with_pdb_list=_reply_empty
alias _reply_with_maxlag_list=_reply_empty
alias _reply_with_sql_translation_profile_list=_reply_empty
alias _reply_with_retention_list=_reply_empty
alias _reply_with_replay_init_time_list=_reply_empty
alias _reply_with_pqservice_list=_reply_empty
alias _reply_with_pqpool_list=_reply_empty
alias _reply_with_gsmflags_list=_reply_empty
alias _reply_with_address_list=_reply_empty
alias _reply_with_subnet_list=_reply_empty
alias _reply_with_nettype_list=_reply_empty
alias _reply_with_pingtarget_list=_reply_empty
alias _reply_with_pwfile_list=_reply_empty
alias _reply_with_proxy_list=_reply_empty
alias _reply_with_timeout_list=_reply_empty
alias _reply_with_domain_list=_reply_empty
alias _reply_with_spfile_list=_reply_empty
alias _reply_with_dbname_list=_reply_empty
alias _reply_with_acfspath_list=_reply_empty
alias _reply_with_emport_list=_reply_empty
alias _reply_with_onslocalport_list=_reply_empty
alias _reply_with_onsremoteport_list=_reply_empty
alias _reply_with_remoteservers_list=_reply_empty
alias _reply_with_clientdata_list=_reply_empty
alias _reply_with_count_list=_reply_empty
alias _reply_with_endpoints_list=_reply_empty
alias _reply_with_invitednodes_list=_reply_empty
alias _reply_with_invitedsubnets_list=_reply_empty
alias _reply_with_scanname_list=_reply_empty
alias _reply_with_min_list=_reply_empty
alias _reply_with_max_list=_reply_empty
alias _reply_with_importance_list=_reply_empty
alias _reply_with_category_list=_reply_empty
alias _reply_with_storage_list=_reply_empty
alias _reply_with_network_number_list=_reply_empty
alias _reply_with_description_list=_reply_empty
alias _reply_with_path_list=_reply_empty
alias _reply_with_options_list=_reply_empty
alias _reply_with_clients_list=_reply_empty
alias _reply_with_user_list=_reply_empty
alias _reply_with_fsoptions_list=_reply_empty
alias _reply_with_appid_list=_reply_empty
alias _reply_with_auxvolumes_list=_reply_empty
alias _reply_with_checkinterval_list=_reply_empty
alias _reply_with_exportserver_list=_reply_empty
alias _reply_with_exportpath_list=_reply_empty
alias _reply_with_mountoptions_list=_reply_empty
alias _reply_with_dbtype_list=_reply_empty

function _reply_with_fstype_list
{
	# Only for linux EXT. ?
	_reply "ACFS EXT3 EXT4"
}

function _reply_with_autostart_list
{
	_reply "ALWAYS NEVER RESTORE"
}

function _reply_with_serverpool_list
{
	if [ -v serverpool_list_cache ]
	then
		if [ $(( SECONDS - tt_serverpool_list_cache )) -lt $(( 60 * 10 )) ]
		then
			_reply "$serverpool_list_cache"
			return 0
		fi
		# cache to old.
	fi

	typeset -g serverpool_list_cache="$(srvctl status srvpool			|\
											grep "^Server pool name:"	|\
											awk '{ print $4 }'			|\
											xargs)"
	typeset	-gi	tt_serverpool_list_cache=$SECONDS

	_reply "$serverpool_list_cache"
}

function _reply_with_policy_list
{	# add database -policy
	_reply "automatic manual norestart"
}

function _reply_with_role_list
{	# add database -role
	_reply "primary physical_standby logical_standby snapshot_standby far_sync"
}

function _reply_with_failovertype_list
{	# add service
	_reply "none session select transaction"
}

function _reply_with_failovermethod_list
{	# add service
	_reply "none basic"
}

function _reply_with_clbgoal_list
{	# add service
	_reply "short long"
}

function _reply_with_rlbgoal_list
{	# add service
	_reply "service_time throughput none"
}

function _reply_true_false
{
	_reply "true false"
}

alias _reply_with_notification_list=_reply_true_false
alias _reply_with_global_list=_reply_true_false
alias _reply_with_commit_outcome_list=_reply_true_false
alias _reply_with_dtp_list=_reply_true_false

function _reply_with_session_state_list
{	# add service
	_reply "static dynamic"
}

function _reply_with_cardinality_list
{
	_reply "uniform singleton"
}

function _reply_with_tafpolicy_list
{
	_reply "none basic preconnect"
}

#	$1 option name, if not begin with a dash return 1.
#
#	If a callback like _reply_with_[option]_list (the dash is removed) exist
#	its called and return 0, if no callback exist return 1.
#
#	-db is translated to -database and -s is translated to -service
function _reply_for_option
{
	typeset		option="$1"
	[ "${option:0:1}" != "-" ] && return 1 || true

	case $option in
		-s)
			option="-service"
			;;
		-db)
			option="-database"
			;;
	esac

	typeset cb_name="_reply_with_${option:1}_list"
	case "$(type -t "$cb_name")" in
		function)
				:
			;;

		alias)
			# if cb_name is an alias name the call don't work even with option
			# shopt -s expand_aliases, work only when use the alias name directly.
			_log "_reply_for_option : translate alias $cb_name"
			cb_name=$(alias $cb_name |cut -d\' -f2)
			;;

		*)
			_log "_reply_for_option : $option not found"
			return 1
			;;
	esac

	_log "_reply_for_option call : $cb_name"
	$cb_name
	return 0
}

#	============================================================================
#	Callback functions for commands
#		_reply_for_cmd_<command_name>
#		_next_reply_for_cmd<command_name>
#			only if generic function _next_reply_for_cmd is not suitable.

#	reply for command status
function _reply_for_cmd_status
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -serverpool -thisversion -thishome
										-force -verbose"
			else
				_reply_with_options "-db -thisversion -thishome
										-force -verbose"
			fi
			;;

		instance)
			_reply_with_options "-db -node -instance -force -verbose"
			;;

		service)
			_reply_with_options "-db -service -force -verbose"
			;;

		nodeapps)
			_reply_with_options "-node"
			;;

		vip)
			_reply_with_options "-node -vip -verbose"
			;;

		listener)
			_reply_with_options "-listener -verbose"
			;;

		asm)
			_reply_with_options "-detail -verbose"
			;;

		scan|scan_listener)
			_reply_with_options "-netnum -scannumber -all -verbose"
			;;

		srvpool)
			_reply_with_options "-serverpool -detail"
			;;

		server)
			_reply_with_options "-servers -detail"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		rhpserver)
			COMPREPLY=()
			;;

		rhpclient)
			COMPREPLY=()
			;;

		home)
			if _is_cluster
			then
				_reply_with_options "-node -oraclehome -statefile"
			else
				_reply_with_options "-oraclehome -statefile"
			fi
			;;

		filesystem)
			_reply_with_options "-device -verbose"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node -all"
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node -detail -verbose"
			else
				_reply_with_options "-diskgroup -detail -verbose"
			fi
			;;

		cvu)
			_reply_with_options "-node"
			;;

		gns)
			_reply_with_options "-node -verbose"
			;;

		mgmtdb)
			_reply_with_options "-verbose"
			;;

		mgmtlsnr)
			_reply_with_options "-verbose"
			;;

		exportfs)
			_reply_with_options "-name -id"
			;;

		havip)
			_reply_with_options "-id"
			;;

		mountfs)
			_reply_with_options "-name"
			;;

		ons)
			_reply_with_options "-verbose"
			;;

		*)
			_log "error object '$object_name' unknow."
			COMPREPLY=()
			;;
	esac
}

#	reply for command start
function _reply_for_cmd_start
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				# -node only for RAC On Node
				# -eval for policy managed
				_reply_with_options "-db -startoption -startconcurrency
									-eval -verbose"
			else
				_reply_with_options "-db -startoption -verbose"
			fi
			;;

		instance) # cluster only
			_reply_with_options "-db -node -instance -startoption"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -serverpool -node -instance
									-pq -global_override -startoption -eval
									-verbose"
			else
				_reply_with_options "-db -service -startoption -global_override
									-verbose"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-startoption -force -proxy -node"
			else
				_reply_with_options "-startoption -force"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -force"
			else
				_reply_with_options "-listener"
			fi
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node"
			else
				_reply_with_options "-diskgroup"
			fi
			;;

		ons) # standalone only
			_reply_with_options "-verbose"
			;;

		home)
			if _is_cluster
			then
				_reply_with_options "-oraclehome -statefile -node"
			else
				_reply_with_options "-oraclehome -statefile"
			fi
			;;

		exportfs)
			_reply_with_options "-name -id"
			;;

		mgmtlsnr)
			_reply_with_options "-node"
			;;

		rhpclient)
			_reply_with_options "-node"
			;;

		cvu)
			_reply_with_options "-node"
			;;

		filesystem)
			_reply_with_options "-device -node"
			;;

		mountfs)
			_reply_with_options "-name -node"
			;;

		rhpserver)
			_reply_with_options "-node"
			;;

		vip)
			_reply_with_options "-node -vip -netnum -relocate -verbose"
			;;

		gns)
			_reply_with_options "-loglevel -node -verbose"
			;;

		nodeapps)
			_reply_with_options "-node -adminhelper -onsonly -verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber -node"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node"
			;;

		havip)
			_reply_with_options "-id -node"
			;;

		mgmtdb)
			_reply_with_options "-startoption -node"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber -node"
			;;

		*)
			_log "_reply_for_cmd_start $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	Exceptions are :
#		on mount reply read
#		on -loglevel reply {1..6}
function _next_reply_for_cmd_start
{
	if ! _reply_for_option $prev_word
	then
		case "$prev_word" in
			read)
				COMPREPLY=( only )
				;;

			-loglevel) # Callback ?
				_reply "{1..6}"
				;;

			*)
				_reply_for_cmd_start
		esac
	fi
}

#	reply for command stop
function _reply_for_cmd_stop
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				# -node only for RAC On Node
				# -eval for policy managed
				_reply_with_options "-db -stopoption -stopconcurrency
									-force -eval -verbose"
			else
				_reply_with_options "-db -stopoption -force -verbose"
			fi
			;;

		instance)	# cluster only
			_reply_with_options "-db -node -instance -stopoption -force
								-failover"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -serverpool -node -instance
									-pq -global_override -force -noreplay
									-eval -verbose"
			else
				_reply_with_options "-db -service -global_override -force
									-verbose"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-stopoption -force -proxy -node"
			else
				_reply_with_options "-stopoption -force"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -node -force"
			else
				_reply_with_options "-listener -force"
			fi
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -force -node"
			else
				_reply_with_options "-diskgroup -force"
			fi
			;;

		ons) # only on standalone.
			_reply_with_options "-verbose"
			;;

		home)
			if _is_cluster
			then
				_reply_with_options "-oraclehome -statefile -stopoption -force
									-node"
			else
				_reply_with_options "-oraclehome -statefile -stopoption -force"
			fi
			;;

		exportfs)
			_reply_with_options "-name -id -force"
			;;

		mgmtlsnr)
			_reply_with_options "-node -force"
			;;

		rhpclient)
			COMPRELY=()
			;;

		cvu)
			_reply_with_options "-force"
			;;

		filesystem)
			_reply_with_options "-device -node -force"
			;;

		mountfs)
			_reply_with_options "-name -node -force"
			;;

		rhpserver)
			COMPRELY=()
			;;

		vip)
			_reply_with_options "-node -vip -netnum -relocate -force -verbose"
			;;

		gns)
			_reply_with_options "-node -force -verbose"
			;;

		nodeapps)
			_reply_with_options "-node -relocate -adminhelper -onsonly -force
								-verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber -force"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node -force"
			;;

		havip)
			_reply_with_options "-id -node -force"
			;;

		mgmtdb)
			_reply_with_options "-stopoption -force"
			;;

		oc4j)
			_reply_with_options "-force -verbose"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber -force"
			;;

		*)
			_log "_reply_for_cmd_stop $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	Exceptions are :
#		on transactional for object instance|database reply local
function _next_reply_for_cmd_stop
{
	if ! _reply_for_option $prev_word
	then
		case "$prev_word" in
			transactional)
				case "$object_name" in
					instance|database)
						_reply "local"
						;;
					*)
						_reply_for_cmd_stop
						;;
				esac
				;;

			*)
				_reply_for_cmd_stop
		esac
	fi
}

#	reply for command config
function _reply_for_cmd_config
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -serverpool -all -verbose"
			else
				_reply_with_options "-db -all -verbose"
			fi
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -serverpool -service -verbose"
			else
				_reply_with_options "-db -service -verbose"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-proxy -detail"
			else
				_reply_with_options "-all"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -asmlistener -leaflistener -all"
			else
				_reply_with_options "-listener"
			fi
			;;

		cvu)
			COMP_REPLY=()
			;;

		ons) # only standalone
			COMP_REPLY=()
			;;

		filesystem)
			_reply_with_options "-device"
			;;

		mgmtlsnr)
			_reply_with_options "-all"
			;;

		oc4j)
			COMPREPLY=()
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber -all"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device"
			;;

		gns)
			_reply_with_options "-detail -subdomain -multicastport -node -port
								-network -status -version -query -list
								-clusterguid -clustername -clustertype
								-loglevel -verbose"
			;;

		mountfs)
			_reply_with_options "-name"
			;;

		rhpclient)
			COMPRELY=()
			;;

		network)
			_reply_with_options "-netnum"
			;;

		rhpserver)
			COMPRELY=()
			;;

		srvpool)
			_reply_with_options "-serverpool"
			;;

		exportfs)
			_reply_with_options "-name -id"
			;;

		mgmtdb)
			_reply_with_options "-verbose -all"
			;;

		nodeapps)
			_reply_with_options "-viponly -onsonly"
			;;

		scan)
			_reply_with_options "-netnum -scannumber -all"
			;;

		vip)
			_reply_with_options "-node -vip"
			;;

		*)
			_log "_reply_for_cmd_config $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command enable
function _reply_for_cmd_enable
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -node"
			else
				_reply_with_options "-db"
			fi
			;;

		instance)
			_reply_with_options "-instance -node"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -instance -node
									-global_override"
			else
				_reply_with_options "-db -service -global_override"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-proxy -node"
			else
				COMPREPLY=()
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -node"
			else
				_reply_with_options "-listener"
			fi
			;;

		nodeapps)
			_reply_with_options "-adminhelper -verbose"
			;;

		vip)
			_reply_with_options "-vip -verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		rhpserver)
			_reply_with_options "-node"
			;;

		rhpclient)
			_reply_with_options "-node"
			;;

		filesystem)
			_reply_with_options "-device"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node"
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node"
			else
				_reply_with_options "-diskgroup"
			fi
			;;

		gns)
			_reply_with_options "-node -verbose"
			;;

		cvu)
			_reply_with_options "-node"
			;;

		mgmtdb)
			_reply_with_options "-node"
			;;

		mgmtlsnr)
			_reply_with_options "-node"
			;;

		exportfs)
			_reply_with_options "-name"
			;;

		havip)
			_reply_with_options "-id -node"
			;;

		mountfs)
			_reply_with_options "-name -node"
			;;

		ons)
			_reply_with_options "-verbose"
			;;

		*)
			_log "_reply_for_cmd_enable $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command disable
function _reply_for_cmd_disable
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -node"
			else
				_reply_with_options "-db"
			fi
			;;

		instance)
			_reply_with_options "-db -instance"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -instance -node
									-global_override"
			else
				_reply_with_options "-db -service -node -global_override"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-proxy -node"
			else
				COMPREPLY=()
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -node"
			else
				_reply_with_options "-listener"
			fi
			;;

		nodeapps)
			_reply_with_options "-adminhelper -verbose"
			;;

		vip)
			_reply_with_options "-vip -verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		rhpserver)
			_reply_with_options "-node"
			;;

		rhpclient)
			_reply_with_options "-node"
			;;

		filesystem)
			_reply_with_options "-device"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node"
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node"
			else
				_reply_with_options "-diskgroup"
			fi
			;;

		gns)
			_reply_with_options "-node -verbose"
			;;

		cvu)
			_reply_with_options "-node"
			;;

		mgmtdb)
			_reply_with_options "-node"
			;;

		mgmtlsnr)
			_reply_with_options "-node"
			;;

		exportfs)
			_reply_with_options "-name"
			;;

		havip)
			_reply_with_options "-id -node"
			;;

		mountfs)
			_reply_with_options "-name -node"
			;;

		ons)
			_reply_with_options "-verbose"
			;;

		*)
			_log "_reply_for_cmd_disable $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command getenv
function _reply_for_cmd_getenv
{
	case "$object_name" in
		database)
			_reply_with_options "-db -envs"
			;;

		nodeapps)
			_reply_with_options "-viponly -onsonly -envs"
			;;

		vip)
			_reply_with_options "-vip -envs"
			;;

		listener)
			_reply_with_options "-listener -envs"
			;;

		asm)
			_reply_with_options "-envs"
			;;

		mgmtdb)
			_reply_with_options "-envs"
			;;

		mgmtlsnr)
			_reply_with_options "-envs"
			;;

		*)
			_log "_reply_for_cmd_getenv $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command setenv
function _reply_for_cmd_setenv
{
	# always put -env before -envs
	case "$object_name" in
		database)
			_reply_with_options "-db -env -envs"
			;;

		nodeapps)
			_reply_with_options "-env -envs -viponly -onsonly -verbose"
			;;

		vip)
			_reply_with_options "-vip -env -envs -verbose"
			;;

		listener)
			_reply_with_options "-listener -env -envs"
			;;

		asm)
			_reply_with_options "-env -envs"
			;;

		mgmtdb)
			_reply_with_options "-env -envs"
			;;

		mgmtlsnr)
			_reply_with_options "-env -envs"
			;;

		*)
			_log "_reply_for_cmd_setenv $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command unsetenv
function _reply_for_cmd_unsetenv
{
	case "$object_name" in
		database)
			_reply_with_options "-db -envs"
			;;

		nodeapps)
			_reply_with_options "-envs -viponly -onsonly -verbose"
			;;

		vip)
			_reply_with_options "-vip -envs -verbose"
			;;

		listener)
			_reply_with_options "-listener -envs"
			;;

		asm)
			_reply_with_options "-envs"
			;;

		mgmtdb)
			_reply_with_options "-envs"
			;;

		mgmtlsnr)
			_reply_with_options "-envs"
			;;

		*)
			_log "_reply_for_cmd_unsetenv $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

function _reply_for_cmd_add
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -oraclehome -dbtype -server -instance
									-timeout -node -domain -spfile -pwfile
									-role -startoption -stopoption -dbname
									-policy -serverpool -pqpool -diskgroup
									-acfspath -startconcurrency -stopconcurrency
									-eval -fixed -verbose"
			else
				_reply_with_options "-db -oraclehome -domain -spfile -pwfile
									-role -startoption -stopoption -dbname
									-instance -policy -diskgroup -verbose"
			fi
			;;

		instance)
			_reply_with_options "-db -instance -node -force"
			;;

		service)
			if _is_cluster
			then
				if _option_is_used -update
				then # After -update only options available are :
					_reply_with_options "-preferred -available -force -verbose"
				else
					_reply_with_options "-db -service -preferred -available
									-serverpool -cardinality -netnum -tafpolicy
									-role -policy -failovertype -failovermethod
									-failoverdelay -failoverretry -pdb -maxlag
									-clbgoal -rlbgoal -dtp -notification
									-global -preferred -available
									-sql_translation_profile -commit_outcome
									-retention -replay_init_time -session_state
									-pqservice -pqpool -gsmflags -eval
									-update"
				fi
			else
				_reply_with_options "-db -service -role -policy -failovertype
								-failovermethod -failoverdelay -failoverretry
								-edition -pdb -maxlag -clbgoal -rlbgoal
								-notification -global -sql_translation_profile
								-commit_outcome -retention -replay_init_time
								-session_state -force -verbose"
			fi
			;;

		nodeapps)
			_reply_with_options "-node -address -subnet -emport -onslocalport
								-onsremoteport -remoteservers -skip -clientdata
								-pingtarget -verbose"
			;;

		vip)
			_reply_with_options "-node -address -netnum -skip -verbose"
			;;

		network)
			_reply_with_options "-netnum -subnet -nettype -pingtarget -leaf
								-verbose"
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-listener -pwfile -flex -count -proxy"
			else
				_reply_with_options "-listener -spfile -pwfile -diskstring"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -oraclehome -netnum -asmlistener
									-leaflistener -subnet -skip -endpoints
									-invitednodes -invitedsubnets"
			else
				_reply_with_options "-listener -oraclehome -skip -endpoints"
			fi
			;;

		scan)
			_reply_with_options "-scanname -netnum"
			;;

		scan_listener)
			_reply_with_options "-netnum -listener -skip -endpoints
								-invitednodes -invitedsubnets"
			;;

		srvpool)
			_reply_with_options "-serverpool -min -max -importance -servers
								-category -eval -force -verbose"
			;;

		oc4j)
			_reply_with_options "-verbose"
			;;

		rhpserver)
			_reply_with_options "-storage -diskgroup"
			;;

		rhpclient)
			_reply_with_options "-clientdata -diskgroup -storage"
			;;

		havip)
			_reply_with_options "-id -address -netnum network_number
								-description"
			;;

		exportfs)
			_reply_with_options "-name -path -id -options -clients"
			;;

		filesystem)
			_reply_with_options "-device -volume -diskgroup -path -user -node
								-serverpool -fstype -fsoptions -description
								-appid -autostart -auxvolumes"
			;;

		gns)
			_reply_with_options "-clientdata -domain -vip -skip -verbose"
			;;

		cvu)
			_reply_with_options "-checkinterval"
			;;

		mgmtdb)
			_reply_with_options "-domain"
			;;

		mgmtlsnr)
			_reply_with_options "-endpoints -skip"
			;;

		mountfs)
			_reply_with_options "-name -path -exportserver -exportpath
								-mountoptions -user"
			;;

		ons)
			_reply_with_options "-emport -onslocalport -onsremoteport
								-remoteservers -verbose"
			;;

		*)
			_log "_reply_for_cmd_add $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

function _next_reply_for_cmd_add
{
	if [ "$object_name" == "instance" ]
	then
		COMPREPLY=()
		return 0
	fi

	case "$prev_word" in
		-db|-instance)
			if [ $object_name == database ]
			then
				COMPREPLY=()
				return 0
			fi

			;;

		-service)
			if [ $object_name == service ]
			then
				COMPREPLY=()
				return 0
			fi
			;;

		-serverpool)
			if [ $object_name == srvpool ]
			then
				COMPREPLY=()
				return 0
			fi
			;;
	esac

	if ! _reply_for_option "$prev_word"
	then
		_reply_for_cmd_add
	fi
}

function _reply_for_cmd_remove
{
	case "$object_name" in
		database)
			_reply_with_options "-db -force -noprompt -verbose"
			;;

		instance)
			_reply_with_options "-db -instance -force -noprompt"
			;;

		service)
			_reply_with_options "-db -service -global_override -force"
			;;

		nodeapps)
			_reply_with_options "-force -noprompt -verbose"
			;;

		vip)
			_reply_with_options "-vip -force -noprompt -verbose"
			;;

		network)
			_reply_with_options "-netnum -all -force -verbose"
			;;

		asm)
			_reply_with_options "-proxy -force"
			;;

		listener)
			_reply_with_options "-listener -all -force"
			;;

		scan)
			_reply_with_options "-netnum -force -noprompt"
			;;

		scan_listener)
			_reply_with_options "-netnum -force -noprompt"
			;;

		srvpool)
			_reply_with_options "-serverpool -eval -verbose"
			;;

		oc4j)
			_reply_with_options "-force -verbose"
			;;

		rhpserver)
			_reply_with_options "-force"
			;;

		rhpclient)
			_reply_with_options "-force"
			;;

		havip)
			_reply_with_options "-id -force"
			;;

		exportfs)
			_reply_with_options "-name -force"
			;;

		filesystem)
			_reply_with_options "-device -force"
			;;

		diskgroup)
			_reply_with_options "-diskgroup -force"
			;;

		gns)
			_reply_with_options "-force -verbose"
			;;

		cvu)
			_reply_with_options "-force"
			;;

		mgmtdb)
			_reply_with_options "-force -noprompt -verbose"
			;;

		mgmtlsnr)
			_reply_with_options "-force"
			;;

		mountfs)
			_reply_with_options "-name -force"
			;;

		*)
			_log "_reply_for_cmd_remove $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	End callback functions for commands.
#	============================================================================

#	If a function named _next_reply_for_cmd_$command exists, it's called.
#	Else call function _reply_for_option, if return 1 call _reply_for_cmd_$command
function _next_reply_for_cmd
{
	if _function_exists _next_reply_for_cmd_$command
	then
		_next_reply_for_cmd_$command
	elif ! _reply_for_option "$prev_word"
	then
		_reply_for_cmd_$command
	fi
}

function _srvctl_complete
{
	#	srvctl <command> <object> [<options>]
	#	COMP_WORD[0] == srvctl
	#	COMP_WORD[1] == command
	#	COMP_WORD[2] == object
	#	COMP_WORD[3] == first option
	typeset	-ri	icommand=1
	typeset	-ri	iobject=2
	typeset	-ri	ifirstoption=3

	typeset -r	command_list="enable disable start stop status add remove modify
							update getenv setenv unsetenv config upgrade
							downgrade"

	typeset	-r	prev_word="${COMP_WORDS[COMP_CWORD-1]}"
	typeset -r	command=${COMP_WORDS[icommand]}
	typeset -r	object_name=${COMP_WORDS[iobject]}

	#	srvctl <command> <object> firstoption ...
	_log
	_log "${COMP_WORDS[*]}"
	_log "command       : $command"
	_log "object        : $object_name"
	_log "first option  : ${COMP_WORDS[ifirstoption]}"
	_log "cur_word      : ${COMP_WORDS[COMP_CWORD]}"
	_log "prev_word     : $prev_word"
	_log "COMP_CWORD    : $COMP_CWORD"

	if [[ "$prev_word" == "srvctl" ]]
	then # srvctl TAB
		_reply "${command_list}"
	elif [[ "$command_list" == *"$prev_word"* ]]
	then # srvctl <command> TAB
		_reply_with_object_list
	elif [[ "$object_list" == *"$prev_word"* ]]
	then # srvctl <command> <object> TAB
		if _function_exists _reply_for_cmd_${command}
		then # $command is implemented.
			_reply_for_cmd_${command}
		else
			_log "TODO : command '$command' not supported."
		fi
	else # srvctl <command> <object> opt1 opt2 ... TAB
		if _function_exists _reply_for_cmd_${command}
		then # $command is implemented.
			_next_reply_for_cmd
		else
			_log "TODO : command '$command' not supported."
		fi
	fi

	_log "COMPREPLY : '${COMPREPLY[*]}'"
}

complete -F _srvctl_complete srvctl
