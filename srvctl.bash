# bash completion support for srvctl 12cR1
# vim: ts=4:sw=4:filetype=sh:cc=81

# Copyright (C) 2016,2017 Philippe Leroux <philippe.lrx@gmail.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

#	============================================================================
#	Pour mÃ©mo :
#		COMP_WORDS	is an array of words in the current command line.
#		COMP_CWORD	is the index of the current word in the command line.
#		COMPREPLY	is a list of replies.
#	============================================================================

#	Work only with : export SRVCTL_LOG=yes
function _log
{
	if [ "$SRVCTL_LOG" == yes ]
	then # One log per user.
		echo "$@" >> /tmp/srvctl_completion_${USER}.log
	fi
}

#	return 0 if cluster, 1 if standalone server
function _is_cluster
{
	[ ! -v count_nodes ] && typeset	-rgi count_nodes=$(wc -l<<<"$(olsnodes)") || true
	[ $count_nodes -gt 1 ] && return 0 || return 1
}

#	print to stdout dbname index in COMP_WORDS, -1 if not found.
function _get_dbname_index
{
	for i in $( seq $ifirstoption ${#COMP_WORDS[@]} )
	do
		if [[ ${COMP_WORDS[i]} == "-db" || ${COMP_WORDS[i]} == "-database" ]]
		then
			[ x"${COMP_WORDS[i+1]}" == x ] && echo -1 || echo $(( i + 1 ))
			return 0
		fi
	done

	echo -1
}

#	build the reply : COMPREPLY is set.
function _reply
{
	COMPREPLY=( $( compgen -W "$@" -- ${COMP_WORDS[COMP_CWORD]} ) )
}

# Generated by script : all_objects_for_cmd.sh
# Built object_list for current command
# srvctl version: 12.1.0.2.0
function _build_object_list_cluster
{
	case "$command" in
		relocate)
			typeset -g object_list="database service server vip scan scan_listener oc4j rhpserver rhpclient gns cvu mgmtdb filesystem asm havip"
			;;
		downgrade)
			typeset -g object_list="database"
			;;
		export)
			typeset -g object_list="gns"
			;;
		stop)
			typeset -g object_list="database instance service nodeapps vip asm listener scan scan_listener oc4j rhpserver rhpclient havip exportfs home filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		import)
			typeset -g object_list="gns"
			;;
		add)
			typeset -g object_list="database instance service service nodeapps vip network asm listener scan scan_listener srvpool oc4j rhpserver rhpclient havip exportfs filesystem gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		start)
			typeset -g object_list="database instance service nodeapps vip asm listener scan scan_listener oc4j rhpserver rhpclient havip exportfs home filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		status)
			typeset -g object_list="database instance service nodeapps vip listener asm scan scan_listener srvpool server oc4j rhpserver rhpclient home filesystem volume diskgroup cvu gns mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		remove)
			typeset -g object_list="database instance service nodeapps vip network asm listener scan scan_listener srvpool oc4j rhpserver rhpclient havip exportfs filesystem diskgroup gns cvu mgmtdb mgmtlsnr mountfs"
			;;
		config)
			typeset -g object_list="database service nodeapps vip network asm listener scan scan_listener srvpool oc4j rhpserver rhpclient filesystem volume gns cvu exportfs mgmtdb mgmtlsnr mountfs"
			;;
		predict)
			typeset -g object_list="database service asm diskgroup filesystem vip network listener scan scan_listener oc4j"
			;;
		unsetenv)
			typeset -g object_list="database nodeapps vip listener asm mgmtdb mgmtlsnr"
			;;
		upgrade)
			typeset -g object_list="database"
			;;
		setenv)
			typeset -g object_list="database nodeapps vip listener asm mgmtdb mgmtlsnr"
			;;
		enable)
			typeset -g object_list="database instance service asm listener nodeapps vip scan scan_listener oc4j rhpserver rhpclient filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		disable)
			typeset -g object_list="database instance service asm listener nodeapps vip scan scan_listener oc4j rhpserver rhpclient filesystem volume diskgroup gns cvu mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		convert)
			typeset -g object_list="database database"
			;;
		getenv)
			typeset -g object_list="database nodeapps vip listener asm mgmtdb mgmtlsnr"
			;;
		modify)
			typeset -g object_list="database instance service service service service asm nodeapps listener network scan scan_listener srvpool oc4j rhpserver rhpclient filesystem gns cvu mgmtdb mgmtlsnr exportfs havip mountfs"
			;;
		update)
			typeset -g object_list="listener scan_listener database mgmtdb instance gns"
			;;
		*)
			_log "$command not supported."
			typeset -g object_list=""
	esac
}

# Generated by script : all_objects_for_cmd.sh
# Built object_list for current command
# srvctl version: 12.1.0.2.0
function _build_object_list_standalone
{
	case "$command" in
		downgrade)
			typeset -g object_list="database"
			;;
		stop)
			typeset -g object_list="database service asm listener diskgroup ons home"
			;;
		add)
			typeset -g object_list="database service asm listener ons"
			;;
		start)
			typeset -g object_list="database service asm listener diskgroup ons home"
			;;
		status)
			typeset -g object_list="database service asm listener diskgroup ons home"
			;;
		remove)
			typeset -g object_list="database service asm listener diskgroup ons"
			;;
		config)
			typeset -g object_list="database service asm listener ons"
			;;
		unsetenv)
			typeset -g object_list="database asm listener"
			;;
		upgrade)
			typeset -g object_list="database"
			;;
		setenv)
			typeset -g object_list="database asm listener"
			;;
		enable)
			typeset -g object_list="database service asm listener diskgroup ons"
			;;
		disable)
			typeset -g object_list="database service asm listener diskgroup ons"
			;;
		getenv)
			typeset -g object_list="database asm listener"
			;;
		modify)
			typeset -g object_list="database service asm listener ons"
			;;
		update)
			typeset -g object_list="database"
			;;
		*)
			_log "$command not supported."
			typeset -g object_list=""
	esac
}

#	init global variable object_list with all objects for the current command.
#	reply with object_list
function _reply_with_object_list
{
	if _is_cluster
	then
		_build_object_list_cluster
	else
		_build_object_list_standalone
	fi

	_reply "$object_list"
}

#	return 0 if $1 is used in COMP_WORDS, else return 1
function _option_is_used
{
	typeset	-r opt="$1"

	typeset i
	for i in $( seq $ifirstoption ${#COMP_WORDS[@]} )
	do
		[ "$opt" == "${COMP_WORDS[i]}" ] && return 0 || true
	done

	return 1 # not found
}

#	$@	option_list
#	print to stdout option_list with used options removed.
function _remove_used_options
{
	typeset	option_list="$@"

	for i in $( seq $ifirstoption ${#COMP_WORDS[@]} )
	do
		if [[ x"${COMP_WORDS[i]}" != x && $i -ne $COMP_CWORD 
				&& "$option_list" == *"${COMP_WORDS[i]}"* ]]
		then
			option_list=${option_list/${COMP_WORDS[i]}/}
		fi
	done

	echo $option_list
}

#	Ex : srvctl stop service -db db_name [-node | -instance]
#	You can use -node or -instance, together it's an error.
#
#	$1 list options
#	print new list options to stdout.
function _remove_exclusive_options
{
	typeset	option_list="$@"

	typeset -A	exclusive_options
	exclusive_options+=( [list_1]="-db -serverpool -thisversion -thishome" )
	exclusive_options+=( [list_2]="-instance -node" )
	exclusive_options+=( [list_3]="-netnum -scannumber" )
	exclusive_options+=( [list_4]="-service -startoption" )
	exclusive_options+=( [list_5]="-listener -asmlistener -leaflistener" )
	exclusive_options+=( [list_6]="-env -envs" ) # order is important.

	typeset	-r	cur_word="${COMP_WORDS[COMP_CWORD]}"

	for id in ${!exclusive_options[@]}
	do
		typeset exlu_opts=${exclusive_options[$id]}
		typeset option
		for option in $exlu_opts
		do
			if [ "$option" != "$cur_word" ] && _option_is_used "$option"
			then
				typeset o2r	# option to removed.
				for o2r in ${exlu_opts/$option/}
				do	# cannot use option $o2r with $option, remove it.
					option_list=${option_list/$o2r/}
				done
				break
			fi
		done
	done

	echo "$option_list"
}

#	$1 option_list
#	before to reply :
#		- remove options already in use.
#		- remove incompatible options.
#
#	With only one option use _reply !
function _reply_with_options
{
	typeset	option_list="$@"

	if [ $COMP_CWORD -ne $ifirstoption ]
	then
		# Call order is important !
		option_list="$(_remove_exclusive_options $option_list)"
		option_list="$(_remove_used_options $option_list)"
	fi

	_reply "$option_list"
}

#	============================================================================
#	Callback functions : _reply_with_[option]_list (option without dash)
#	return values for an option.

function _reply_with_database_list
{
	_reply "$(crsctl stat res							|\
					grep "\.db$"						|\
					sed "s/NAME=ora\.\(.*\).db/\1/g"	|\
					xargs)"
}

function _reply_with_diskgroup_list
{
	_reply	"$(crsctl stat res						|\
					grep -E "ora.*.dg$"				|\
					sed "s/NAME=ora.\(.*\).dg/\1/g"	|\
					xargs)"
}

function _reply_with_listener_list
{
	#	For RAC database we must exclude listener for scan vips.
	_reply	"$(crsctl stat res							|\
					grep -E "NAME=ora.*.lsnr$"			|\
					grep -v "SCAN"						|\
					sed "s/NAME=ora.\(.*\).lsnr/\1/g"	|\
					xargs)"
}

function _reply_with_oraclehome_list
{
	_reply	"$(cat /etc/oratab						|\
					grep -E "^(\+|[A-Z])"			|\
					sed "s/.*:\(.*\):[Y|N].*/\1/g"	|\
					xargs)"
}

function _reply_with_vip_list
{
	_reply	"$(crsctl stat res							|\
					grep -E "NAME=ora.*.vip$"			|\
					grep -v "scan"						|\
					sed "s/NAME=ora.\(.*\).vip/\1/g"	|\
					xargs)"
}

function _reply_with_netnum_list
{
	typeset -i count_net=$(crsctl stat res|grep -E "\.network$"|wc -l)

	_reply "{1..$count_net}"
}

function _reply_with_scannumber_list
{
	_reply "1 2 3"
}

function _reply_with_node_number_list
{
	[ ! -v count_nodes ] && _is_cluster || true

	_reply "{1..$count_nodes}"
}

function _reply_with_startconcurrency_list
{
	_reply_with_node_number_list
}

function _reply_with_stopconcurrency_list
{
	_reply_with_node_number_list
}

function _reply_with_node_list
{
	_reply "$(olsnodes | xargs)"
}

function _reply_with_servers_list
{
	_reply_with_node_list
}

function _reply_with_service_list
{
	typeset	-ri idbname=$(_get_dbname_index)
	if [ $idbname -eq -1 ]
	then # return all services
		_reply "$(crsctl stat res							|\
						grep -E "ora.*.svc$"				|\
						sed "s/NAME=ora\.\(.*\)\.svc/\1/g"	|\
						xargs)"
	else # return services for specified database.
		typeset -r dbname=$(tr [:upper:] [:lower:]<<<"${COMP_WORDS[idbname]}")
		_reply "$(crsctl stat res										|\
						grep -Ei "ora.$dbname.*.svc$"					|\
						sed "s/NAME=ora\.${dbname}\.\(.*\)\.svc/\1/g"	|\
						xargs)"
	fi
}

function _reply_with_instance_list
{
	typeset	-ri idbname=$(_get_dbname_index)
	if [ $idbname -eq -1 ]
	then
		COMPREPLY=()
		return 0
	fi

	if [ -v instance_list ]
	then # TODO : invalidate cache on remove or add commands.
		if [ $(( SECONDS - tt_instance_list )) -lt $(( 60 * 10 )) ]
		then
			_reply "$instance_list"
			return 0
		fi
		# cache to old.
	fi

	typeset	cmd="srvctl status database -db ${COMP_WORDS[idbname]}"
	cmd="$cmd | sed 's/Instance \(.*\) is.*/\1/g' | xargs"
	_log "cmd='$cmd'"

	typeset -g	instance_list="$(eval $cmd)"
	typeset	-gi	tt_instance_list=$SECONDS

	_reply "$instance_list"
}

function _reply_with_startoption_list
{
	_reply "open mount read"
}

function _reply_with_stopoption_list
{
	_reply "normal transactional immediate abort"
}

function _reply_with_statefile_list
{	# user must provide a file name.
	COMPREPLY=()
}

function _reply_with_volume_list
{	# user must provide Volume name
	COMPREPLY=()
}

function _reply_with_device_list
{	# user must provide Volume device path
	COMPREPLY=()
}

function _reply_with_name_list
{	# user must provide a name
	COMPREPLY=()
}

function _reply_with_id_list
{	# user must provide unique ID for 'havip'
	COMPREPLY=()
}

function _reply_with_serverpool_list
{
	if [ -v pool_list ]
	then # TODO : invalidate cache on remove or add commands.
		if [ $(( SECONDS - tt_pool_list )) -lt $(( 60 * 10 )) ]
		then
			_reply "$pool_list"
			return 0
		fi
		# cache to old.
	fi

	typeset -g pool_list="$(srvctl status srvpool			|\
								grep "^Server pool name:"	|\
								awk '{ print $4 }'			|\
								xargs)"
	typeset	-gi	tt_pool_list=$SECONDS

	_reply "$pool_list"
}

function _reply_with_envs_list
{	# envs should be followed by a value.
	COMPREPLY=()
}

function _reply_with_env_list
{	# env should be followed by a value.
	COMPREPLY=()
}

#	End callback functions.
#	============================================================================

function _function_exists
{
	type -t "$1" >/dev/null 2>&1
}

#	$1 option name, if not begin with a dash return 1.
#
#	Must exist a callback function like _reply_with_[option]_list, the dash is
#	removed from the option name before the call.
#
#	-db is translated to -database and -s is translated to -service
#
#	return 0 if reply done, else return 1.
function _reply_for_option
{
	typeset		option="$1"
	[ "${option:0:1}" != "-" ] && return 1 || true

	case $option in
		-s)
			option="-service"
			;;
		-db)
			option="-database"
			;;
	esac

	if _function_exists "_reply_with_${option:1}_list"
	then
		_reply_with_${option:1}_list
		return 0
	fi

	_log "_reply_for_option : $option not found"
	return 1
}

#	============================================================================
#	Callback functions for commands
#		_reply_for_cmd_<command_name>
#		_next_reply_for_cmd<command_name>
#			only if generic function _next_reply_for_cmd is not suitable.

#	reply for command status
function _reply_for_cmd_status
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -serverpool -thisversion -thishome
										-force -verbose"
			else
				_reply_with_options "-db -thisversion -thishome
										-force -verbose"
			fi
			;;

		instance)
			#	TODO : standalone CRS
			_reply_with_options "-db -node -instance -force -verbose"
			;;

		service)
			_reply_with_options "-db -service -force -verbose"
			;;

		nodeapps)
			_reply "-node"
			;;

		vip)
			_reply_with_options "-node -vip -verbose"
			;;

		listener)
			_reply_with_options "-listener -verbose"
			;;

		asm)
			_reply_with_options "-detail -verbose"
			;;

		scan|scan_listener)
			_reply_with_options "-netnum -scannumber -all -verbose"
			;;

		srvpool)
			_reply_with_options "-serverpool -detail"
			;;

		server)
			_reply_with_options "-servers -detail"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		rhpserver)
			COMPREPLY=()
			;;

		rhpclient)
			COMPREPLY=()
			;;

		home)
			if _is_cluster
			then
				_reply_with_options "-node -oraclehome -statefile"
			else
				_reply_with_options "-oraclehome -statefile"
			fi
			;;

		filesystem)
			_reply_with_options "-device -verbose"
			;;

		volume)
			#	TODO : standalone CRS
			_reply_with_options "-volume -diskgroup -device -node -all"
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node -detail -verbose"
			else
				_reply_with_options "-diskgroup -detail -verbose"
			fi
			;;

		cvu)
			_reply "-node"
			;;

		gns)
			_reply_with_options "-node -verbose"
			;;

		mgmtdb)
			_reply "-verbose"
			;;

		mgmtlsnr)
			_reply "-verbose"
			;;

		exportfs)
			_reply_with_options "-name -id"
			;;

		havip)
			_reply "-id"
			;;

		mountfs)
			_reply "-name"
			;;

		ons)
			_reply "-verbose"
			;;

		*)
			_log "error object '$object_name' unknow."
			COMPREPLY=()
			;;
	esac
}

#	reply for command start
function _reply_for_cmd_start
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				# -node only for RAC On Node
				# -eval for policy managed
				_reply_with_options "-db -startoption -startconcurrency
									-eval -verbose"
			else
				_reply_with_options "-db -startoption -verbose"
			fi
			;;

		instance) # cluster only
			_reply_with_options "-db -node -instance -startoption"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -serverpool -node -instance
									-pq -global_override -startoption -eval
									-verbose"
			else
				_reply_with_options "-db -service -startoption -global_override
									verbose"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-startoption -force -proxy -node"
			else
				_reply_with_options "-startoption -force"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -force"
			else
				_reply "-listener"
			fi
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node"
			else
				_reply "-diskgroup"
			fi
			;;

		ons) # standalone only
			_reply "-verbose"
			;;

		home)
			if _is_cluster
			then
				_reply_with_options "-oraclehome -statefile -node"
			else
				_reply_with_options "-oraclehome -statefile"
			fi
			;;

		exportfs)
			_reply_with_options "-name -id"
			;;

		mgmtlsnr)
			_reply "-node"
			;;

		rhpclient)
			_reply "-node"
			;;

		cvu)
			_reply "-node"
			;;

		filesystem)
			_reply_with_options "-device -node"
			;;

		mountfs)
			_reply_with_options "-name -node"
			;;

		rhpserver)
			_reply "-node"
			;;

		vip)
			_reply_with_options "-node -vip -netnum -relocate -verbose"
			;;

		gns)
			_reply_with_options "-loglevel -node -verbose"
			;;

		nodeapps)
			_reply_with_options "-node -adminhelper -onsonly -verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber -node"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node"
			;;

		havip)
			_reply_with_options "-id -node"
			;;

		mgmtdb)
			_reply_with_options "-startoption -node"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber -node"
			;;

		*)
			_log "_reply_for_cmd_start $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	Exceptions are :
#		on mount reply read
#		on -loglevel reply {1..6}
function _next_reply_for_cmd_start
{
	if ! _reply_for_option $prev_word
	then
		case "$prev_word" in
			read)
				COMPREPLY=( only )
				;;

			-loglevel) # Callback ?
				_reply "{1..6}"
				;;

			*)
				_reply_for_cmd_start
		esac
	fi
}

#	reply for command stop
function _reply_for_cmd_stop
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				# -node only for RAC On Node
				# -eval for policy managed
				_reply_with_options "-db -stopoption -stopconcurrency
									-force -eval -verbose"
			else
				_reply_with_options "-db -stopoption -force -verbose"
			fi
			;;

		instance)	# cluster only
			_reply_with_options "-db -node -instance -stopoption -force
								-failover"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -serverpool -node -instance
									-pq -global_override -force -noreplay
									-eval -verbose"
			else
				_reply_with_options "-db -service -global_override -force
									-verbose"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-stopoption -force -proxy -node"
			else
				_reply_with_options "-stopoption -force"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -node -force"
			else
				_reply_with_options "-listener -force"
			fi
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -force -node"
			else
				_reply_with_options "-diskgroup -force"
			fi
			;;

		ons) # only on standalone.
			_reply "-verbose"
			;;

		home)
			if _is_cluster
			then
				_reply_with_options "-oraclehome -statefile -stopoption -force
									-node"
			else
				_reply_with_options "-oraclehome -statefile -stopoption -force"
			fi
			;;

		exportfs)
			_reply_with_options "-name -id -force"
			;;

		mgmtlsnr)
			_reply_with_options "-node -force"
			;;

		rhpclient)
			COMPRELY=()
			;;

		cvu)
			_reply "-force"
			;;

		filesystem)
			_reply_with_options "-device -node -force"
			;;

		mountfs)
			_reply_with_options "-name -node -force"
			;;

		rhpserver)
			COMPRELY=()
			;;

		vip)
			_reply_with_options "-node -vip -netnum -relocate -force -verbose"
			;;

		gns)
			_reply_with_options "-node -force -verbose"
			;;

		nodeapps)
			_reply_with_options "-node -relocate -adminhelper -onsonly -force
								-verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber -force"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node -force"
			;;

		havip)
			_reply_with_options "-id -node -force"
			;;

		mgmtdb)
			_reply_with_options "-stopoption -force"
			;;

		oc4j)
			_reply_with_options "-force -verbose"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber -force"
			;;

		*)
			_log "_reply_for_cmd_stop $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	Exceptions are :
#		on transactional for object instance|database reply local
function _next_reply_for_cmd_stop
{
	if ! _reply_for_option $prev_word
	then
		case "$prev_word" in
			transactional)
				case "$object_name" in
					instance|database)
						_reply "local"
						;;
					*)
						_reply_for_cmd_stop
						;;
				esac
				;;

			*)
				_reply_for_cmd_stop
		esac
	fi
}

#	reply for command config
function _reply_for_cmd_config
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -serverpool -all -verbose"
			else
				_reply_with_options "-db -all -verbose"
			fi
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -serverpool -service -verbose"
			else
				_reply_with_options "-db -service -verbose"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-proxy -detail"
			else
				_reply "-all"
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -asmlistener -leaflistener -all"
			else
				_reply "-listener"
			fi
			;;

		cvu)
			COMP_REPLY=()
			;;

		ons) # only standalone
			COMP_REPLY=()
			;;

		filesystem)
			_reply "-device"
			;;

		mgmtlsnr)
			_reply "-all"
			;;

		oc4j)
			COMPREPLY=()
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber -all"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device"
			;;

		gns)
			_reply_with_options "-detail -subdomain -multicastport -node -port
								-network -status -version -query -list
								-clusterguid -clustername -clustertype
								-loglevel -verbose"
			;;

		mountfs)
			_reply "-name"
			;;

		rhpclient)
			COMPRELY=()
			;;

		network)
			_reply "-netnum"
			;;

		rhpserver)
			COMPRELY=()
			;;

		srvpool)
			_reply "-serverpool"
			;;

		exportfs)
			_reply_with_options "-name -id"
			;;

		mgmtdb)
			_reply_with_options "-verbose -all"
			;;

		nodeapps)
			_reply_with_options "-viponly -onsonly"
			;;

		scan)
			_reply_with_options "-netnum -scannumber -all"
			;;

		vip)
			_reply_with_options "-node -vip"
			;;

		*)
			_log "_reply_for_cmd_config $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command enable
function _reply_for_cmd_enable
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -node"
			else
				_reply "-db"
			fi
			;;

		instance)
			_reply_with_options "-instance -node"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -instance -node
									-global_override"
			else
				_reply_with_options "-db -service -global_override"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-proxy -node"
			else
				COMPREPLY=()
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -node"
			else
				_reply_with_options "-listener"
			fi
			;;

		nodeapps)
			_reply_with_options "-adminhelper -verbose"
			;;

		vip)
			_reply_with_options "-vip -verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		rhpserver)
			_reply "-node"
			;;

		rhpclient)
			_reply "-node"
			;;

		filesystem)
			_reply "-device"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node"
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node"
			else
				_reply_with_options "-diskgroup"
			fi
			;;

		gns)
			_reply_with_options "-node -verbose"
			;;

		cvu)
			_reply "-node"
			;;

		mgmtdb)
			_reply "-node"
			;;

		mgmtlsnr)
			_reply "-node"
			;;

		exportfs)
			_reply "-name"
			;;

		havip)
			_reply_with_options "-id -node"
			;;

		mountfs)
			_reply_with_options "-name -node"
			;;

		ons)
			_reply "-verbose"
			;;

		*)
			_log "_reply_for_cmd_enable $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command disable
function _reply_for_cmd_disable
{
	case "$object_name" in
		database)
			if _is_cluster
			then
				_reply_with_options "-db -node"
			else
				_reply_with_options "-db"
			fi
			;;

		instance)
			_reply_with_options "-db -instance"
			;;

		service)
			if _is_cluster
			then
				_reply_with_options "-db -service -instance -node
									-global_override"
			else
				_reply_with_options "-db -service -node -global_override"
			fi
			;;

		asm)
			if _is_cluster
			then
				_reply_with_options "-proxy -node"
			else
				COMPREPLY=()
			fi
			;;

		listener)
			if _is_cluster
			then
				_reply_with_options "-listener -node"
			else
				_reply_with_options "-listener"
			fi
			;;

		nodeapps)
			_reply_with_options "-adminhelper -verbose"
			;;

		vip)
			_reply_with_options "-vip -verbose"
			;;

		scan)
			_reply_with_options "-netnum -scannumber"
			;;

		scan_listener)
			_reply_with_options "-netnum -scannumber"
			;;

		oc4j)
			_reply_with_options "-node -verbose"
			;;

		rhpserver)
			_reply "-node"
			;;

		rhpclient)
			_reply "-node"
			;;

		filesystem)
			_reply "-device"
			;;

		volume)
			_reply_with_options "-volume -diskgroup -device -node"
			;;

		diskgroup)
			if _is_cluster
			then
				_reply_with_options "-diskgroup -node"
			else
				_reply_with_options "-diskgroup"
			fi
			;;

		gns)
			_reply_with_options "-node -verbose"
			;;

		cvu)
			_reply "-node"
			;;

		mgmtdb)
			_reply "-node"
			;;

		mgmtlsnr)
			_reply "-node"
			;;

		exportfs)
			_reply "-name"
			;;

		havip)
			_reply_with_options "-id -node"
			;;

		mountfs)
			_reply_with_options "-name -node"
			;;

		ons)
			_reply "-verbose"
			;;

		*)
			_log "_reply_for_cmd_disable $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command getenv
function _reply_for_cmd_getenv
{
	case "$object_name" in
		database)
			_reply_with_options "-db -envs"
			;;

		nodeapps)
			_reply_with_options "-viponly -onsonly -envs"
			;;

		vip)
			_reply_with_options "-vip -envs"
			;;

		listener)
			_reply_with_options "-listener -envs"
			;;

		asm)
			_reply "-envs"
			;;

		mgmtdb)
			_reply "-envs"
			;;

		mgmtlsnr)
			_reply "-envs"
			;;

		*)
			_log "_reply_for_cmd_getenv $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command setenv
function _reply_for_cmd_setenv
{
	# always put -env before -envs
	case "$object_name" in
		database)
			_reply_with_options "-db -env -envs"
			;;

		nodeapps)
			_reply_with_options "-env -envs -viponly -onsonly -verbose"
			;;

		vip)
			_reply_with_options "-vip -env -envs -verbose"
			;;

		listener)
			_reply_with_options "-listener -env -envs"
			;;

		asm)
			_reply_with_options "-env -envs"
			;;

		mgmtdb)
			_reply_with_options "-env -envs"
			;;

		mgmtlsnr)
			_reply_with_options "-env -envs"
			;;

		*)
			_log "_reply_for_cmd_setenv $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	reply for command unsetenv
function _reply_for_cmd_unsetenv
{
	case "$object_name" in
		database)
			_reply_with_options "-db -envs"
			;;

		nodeapps)
			_reply_with_options "-envs -viponly -onsonly -verbose"
			;;

		vip)
			_reply_with_options "-vip -envs -verbose"
			;;

		listener)
			_reply_with_options "-listener -envs"
			;;

		asm)
			_reply "-envs"
			;;

		mgmtdb)
			_reply "-envs"
			;;

		mgmtlsnr)
			_reply "-envs"
			;;

		*)
			_log "_reply_for_cmd_unsetenv $object_name : todo"
			COMPREPLY=()
			;;
	esac
}

#	End callback functions for commands.
#	============================================================================

#	If a function named _next_reply_for_cmd_$command exists, it's called.
#	Else call function _reply_for_option, if return 1 call _reply_for_cmd_$command
function _next_reply_for_cmd
{
	if _function_exists _next_reply_for_cmd_$command
	then
		_next_reply_for_cmd_$command
	elif ! _reply_for_option "$prev_word"
	then
		_reply_for_cmd_$command
	fi
}

function _srvctl_complete
{
	#	srvctl <command> <object> [<options>]
	#	COMP_WORD[0] == srvctl
	#	COMP_WORD[1] == command
	#	COMP_WORD[2] == object
	#	COMP_WORD[3] == first option
	typeset	-ri	icommand=1
	typeset	-ri	iobject=2
	typeset	-ri	ifirstoption=3

	typeset -r	command_list="enable disable start stop status add remove modify
							update getenv setenv unsetenv config upgrade
							downgrade"

	typeset	-r	prev_word="${COMP_WORDS[COMP_CWORD-1]}"
	typeset -r	command=${COMP_WORDS[icommand]}
	typeset -r	object_name=${COMP_WORDS[iobject]}

	#	srvctl <command> <object> firstoption ...
	_log
	_log "${COMP_WORDS[*]}"
	_log "command       : $command"
	_log "object        : $object_name"
	_log "first option  : ${COMP_WORDS[ifirstoption]}"
	_log "cur_word      : ${COMP_WORDS[COMP_CWORD]}"
	_log "prev_word     : $prev_word"
	_log "COMP_CWORD    : $COMP_CWORD"

	if [[ "$prev_word" == "srvctl" ]]
	then # srvctl TAB
		_reply "${command_list}"
	elif [[ "$command_list" == *"$prev_word"* ]]
	then # srvctl <command> TAB
		_reply_with_object_list
	elif [[ "$object_list" == *"$prev_word"* ]]
	then # srvctl <command> <object> TAB
		if _function_exists _reply_for_cmd_${command}
		then # $command is implemented.
			_reply_for_cmd_${command}
		else
			_log "TODO : command '$command' not supported."
		fi
	else # srvctl <command> <object> opt1 opt2 ... TAB
		if _function_exists _reply_for_cmd_${command}
		then # $command is implemented.
			_next_reply_for_cmd
		else
			_log "TODO : command '$command' not supported."
		fi
	fi

	_log "COMPREPLY : '${COMPREPLY[*]}'"
}

complete -F _srvctl_complete srvctl
